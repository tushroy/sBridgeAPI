package ch.nych.soundtransmitter.receiver;

import android.util.Log;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import ch.nych.soundtransmitter.receiver.tasks.ReceiverTask;
import ch.nych.soundtransmitter.receiver.tasks.SampleBuffer;
import ch.nych.soundtransmitter.receiver.tasks.recording.RecordingTask;
import ch.nych.soundtransmitter.receiver.tasks.transformation.TransformationTask;
import ch.nych.soundtransmitter.util.Configuration;

/**
 * Created by nych on 4/7/16.
 */
public class Receiver {

    /**
     * Local log tag
     */
    private final String logTag = Configuration.LOG_TAG;

    /**
     * The Configuration instance is shared between all tasks
     */
    private Configuration configuration = null;

    /**
     * Indicates if the Receiver is ready
     */
    private boolean initialized = false;

    /**
     * The SampleBuffer instance is shared between the recording and the transformation task
     */
    private SampleBuffer sampleBuffer = null;

    /**
     * Responsible for the parallel execution of the different tasks
     */
    private ExecutorService[] executorServices = null;

    /**
     * As the {@link RecordingTask} has to be killed manually, a reference to the instance is
     * needed.
     */
    private ReceiverTask recordingTask = null;

    /**
     * As the {@link TransformationTask} has to be killed manually, a reference to the instance is
     * needed.
     */
    private ReceiverTask transformationTask = null;

    /**
     * Getter for the local {@link Configuration} instance. Be aware of changing the configuration
     * while the receiver is running. You will need to shutdown and reinitialize the receiver.
     * @return the {@link Configuration} instance
     */
    public Configuration getConfiguration() {
        return this.configuration;
    }

    /**
     * Getter for the local {@link SampleBuffer} instance. This is shared memory for the
     * communication between the {@link RecordingTask} and the {@link TransformationTask}. It is not
     * recommended to access this object!
     * @return the {@link SampleBuffer} instance
     */
    public SampleBuffer getSampleBuffer() {
        return this.sampleBuffer;
    }

    /**
     * This method tries to initialize all required components of the {@link Receiver} module.
     * Therefore a {@link Configuration} instance is needed to load the corresponding preferences
     * for the sound analysis.
     * @param configuration Unless its necessary for a specific reason, try to use a standard
     *                      configuration, generated by
     *                      Configuration.getNew<Definition>Configuration()
     * @return The method returns true if all components could be initialized successfully. If this
     * is not the case, the {@link Configuration} instance could be corrupted. If the argument is
     * null, the method will return false.
     */
    public boolean initReceiver(final Configuration configuration) {
        Log.i(this.logTag, "Initialize Receiver");

        if(configuration == null) {
            Log.e(this.logTag, "Invalid Configuration, Receiver is not ready");
            return false;
        } else {
            this.configuration = configuration;
        }

        this.sampleBuffer = new SampleBuffer(this.configuration);
        this.executorServices = new ExecutorService[]{
                Executors.newSingleThreadExecutor(),
                Executors.newSingleThreadExecutor(),
                Executors.newSingleThreadExecutor()
        };
        this.recordingTask = new RecordingTask(this);
        if(!this.recordingTask.initTask()) {
            return false;
        }
        this.transformationTask = new TransformationTask(this);
        if(!this.transformationTask.initTask()) {
            return false;
        }
        this.initialized = true;
        return true;
    }

    /**
     * This method tries to start the receiver. If the receiver wasn't initialized successfully, the
     * receiving process won't start.
     * @return If the receiver started successfully, the method will return true. Otherwise the
     * method returns false. If this is the case, call the initReceiver() method.
     */
    public boolean startReceiver() {
        Log.i(this.logTag, "Start receiver");
        if(this.initialized) {
            this.executorServices[0].execute(this.recordingTask);
            this.executorServices[1].execute(this.transformationTask);
        } else {
            Log.w(this.logTag, "Could not start Receiver because its not initialized");
            return false;
        }
        return true;
    }

    /**
     * This method stops the receiver and is releasing all resources. This is an important call, as
     * the receiver is using native audio resources. Always stop the receiver instance before
     * shutting down your application!
     */
    public void stopReceiver() {
        Log.i(this.logTag, "Stop receiver");
        this.shutdownAndAwaitTermination();
    }

    /**
     * This method tries to shutdown all tasks and await their termination. Before the executors
     * trying to shutdown their running tasks, the {@link RecordingTask} and the
     * {@link TransformationTask} need to be shutdown manually.
     */
    private void shutdownAndAwaitTermination() {
        Log.d(this.logTag, "Shutdown Receiver");
        this.recordingTask.shutdown();
        this.transformationTask.shutdown();
        for(ExecutorService executor : this.executorServices) {
            Log.d(this.logTag, "Shutdown executor");
            executor.shutdown();
            try {
                if(!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    executor.shutdownNow();
                    if(!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                        Log.e(this.logTag, "Executor did not terminate");
                    }
                }
            } catch (InterruptedException e) {
                Log.w(this.logTag, e.getMessage());
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
}
